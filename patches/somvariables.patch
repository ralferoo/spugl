diff --git a/gen_spu_command_defs.h b/gen_spu_command_defs.h
diff --git a/gen_spu_command_exts.h b/gen_spu_command_exts.h
diff --git a/gen_spu_command_table.h b/gen_spu_command_table.h
diff --git a/primitives.c b/primitives.c
diff --git a/shader.c b/shader.c
index 009b512..9ba9f05 100644
--- a/shader.c
+++ b/shader.c
@@ -343,8 +343,6 @@ void* linearTextureMapFill(void* self, Block* block, ActiveBlock* active, int ta
 	const vec_uint4 xf80=spu_splats((unsigned int)0xf80);
 	const vec_uint4 x1f0=spu_splats((unsigned int)0x1f0);
 	const vec_uint4 x7c=spu_splats((unsigned int)0x7c);
-	const vec_uint4 x38=spu_splats((unsigned int)0x38);
-	const vec_uint4 x7=spu_splats((unsigned int)0x7);
 	const vec_uint4 x20=spu_splats((unsigned int)0x20);
 
 	const vec_float4 f1_0 = spu_splats(1.0f);
@@ -363,6 +361,14 @@ void* linearTextureMapFill(void* self, Block* block, ActiveBlock* active, int ta
 	const vec_uchar16 merge_pixels_23 = (vec_uchar16) {
 		S_0,S_0,S_0,S_0, S_0,S_0,S_0,S_0, 1,5,9,13, 17,21,25,29};
 
+	const vec_uint4 tex_sblk_mask=spu_splats((unsigned int)0x7);
+	const vec_uint4 tex_tblk_mask=spu_splats((unsigned int)0x38);
+	const vec_int4 tex_sblk_shift=spu_splats((int)-29);
+	const vec_int4 tex_tblk_shift=spu_splats((int)-26);
+
+	const vec_int4 s_norm_shift = spu_splats((int)-16);
+	const vec_int4 t_norm_shift = spu_splats((int)-16);
+
 	do {
 		vec_uint4 uAa = (vec_uint4) Aa;
 		vec_uint4 uAb = (vec_uint4) Ab;
@@ -385,8 +391,11 @@ void* linearTextureMapFill(void* self, Block* block, ActiveBlock* active, int ta
 			vec_uint4 t_s = spu_convtu(tf_s,32);
 			vec_uint4 t_t = spu_convtu(tf_t,32);
 
-			vec_uint4 s_blk = spu_and(spu_rlmask(t_s,-29), x7);	//24+5
-			vec_uint4 t_blk = spu_and(spu_rlmask(t_t,-26), x38);	//24+2
+			vec_uint4 s_norm = spu_rlmask(t_s,s_norm_shift);
+			vec_uint4 t_norm = spu_rlmask(t_t,t_norm_shift);
+
+			vec_uint4 s_blk = spu_and(spu_rlmask(t_s,tex_sblk_shift), tex_sblk_mask);
+			vec_uint4 t_blk = spu_and(spu_rlmask(t_t,tex_tblk_shift), tex_tblk_mask);
 			vec_uint4 block_id = spu_add(tex_id_base,spu_or(s_blk,t_blk));
 
 			vec_ushort8 copy_cmp_0 = (vec_ushort8) spu_shuffle(block_id,block_id,shuf_cmp_0);
@@ -428,8 +437,8 @@ void* linearTextureMapFill(void* self, Block* block, ActiveBlock* active, int ta
 			vec_uint4 cache_not_found = spu_cmpeq(cache,spu_splats((unsigned int)32));
 			unsigned int cache_orx = spu_extract(spu_orx(cache_not_found),0);
 			if (__builtin_expect(cache_orx,0)) {  // amazingly gcc does move this out of the loop :)
-				vec_uint4 s = spu_rlmask(t_s,-29);
-				vec_uint4 t = spu_rlmask(t_t,-29);
+				vec_uint4 s = spu_rlmask(s_norm,-13);
+				vec_uint4 t = spu_rlmask(t_norm,-13);
 				return loadMissingTextures(self, block, active, tag,
 					A, left, ptr, tex_keep,
 					block_id, s, t, cache_not_found, pixel);
@@ -437,8 +446,8 @@ void* linearTextureMapFill(void* self, Block* block, ActiveBlock* active, int ta
 
 			// pixel is mask of 1's where we want to draw
 		
-			vec_uint4 s_sub = spu_and(spu_rlmask(t_s,-17), xf80);	//19-2
-			vec_uint4 t_sub = spu_and(spu_rlmask(t_t,-22), x7c);	//24-2
+			vec_uint4 s_sub = spu_and(spu_rlmask(s_norm,-1), xf80);	//19-2
+			vec_uint4 t_sub = spu_and(spu_rlmask(t_norm,-6), x7c);	//24-2
 			vec_uint4 sub_block_pixel = spu_or(s_sub,t_sub);
 
 			vec_uint4 tex_ofs = spu_mulo( (vec_ushort8)cache, tex_ofs_mul);
@@ -453,7 +462,7 @@ void* linearTextureMapFill(void* self, Block* block, ActiveBlock* active, int ta
 			vec_uint4 addr11a = spu_add(addr00, (unsigned int)(32*4+16));
 
 			// if x==32
-			vec_uint4 sb_sub = spu_and(spu_rlmask(t_s,-20), x1f0);
+			vec_uint4 sb_sub = spu_and(spu_rlmask(s_norm,-4), x1f0);
 			vec_uint4 addr10b = spu_add(tex_ofs32,sb_sub);
 			vec_uint4 addr11b = spu_add(addr10b, spu_splats((unsigned int)16));
 
@@ -502,8 +511,8 @@ void* linearTextureMapFill(void* self, Block* block, ActiveBlock* active, int ta
 			vec_uint4 pix3_0 = spu_shuffle(pix3_00,pix3_10,x_shuf3);
 			vec_uint4 pix3_1 = spu_shuffle(pix3_01,pix3_11,x_shuf3);
 
-			vec_uint4 s_pxofs = spu_and(spu_rlmask(t_s,-16), (vec_uint4)0xff);
-			vec_uint4 t_pxofs = spu_and(spu_rlmask(t_t,-16), (vec_uint4)0xff);
+			vec_uint4 s_pxofs = spu_and(s_norm, (vec_uint4)0xff);
+			vec_uint4 t_pxofs = spu_and(t_norm, (vec_uint4)0xff);
 
 			vec_short8 pixel01_ = (vec_short8) spu_shuffle((vec_uint4)pix0_0, (vec_uint4)pix1_0, get0);
 			vec_short8 pixel01_Y = (vec_short8) spu_shuffle((vec_uint4)pix0_1, (vec_uint4)pix1_1, get0);
