diff --git a/activeblock.c b/activeblock.c
index c98fb13..811d518 100644
--- a/activeblock.c
+++ b/activeblock.c
@@ -117,7 +117,7 @@ void blockActivater(Block* block, ActiveBlock* active, int tag)
 	block->pixels = (vec_uint4*) ((void*)&active->pixels[0]);
 
 	if (active->ea_copy == ea) {
-//		printf("re-using same ea %llx in %x -> %x\n", ea, block, active);
+		printf("re-using same ea %llx in %x -> %x\n", ea, block, active);
 		return;
 	}
 	
@@ -141,26 +141,7 @@ void blockActivater(Block* block, ActiveBlock* active, int tag)
 	unsigned long eal_old = (unsigned long) ((void*)active->current_dma);
 	unsigned long eal_new = (unsigned long) ((void*)active->new_dma);
 
-	// if this is an unused block, then we have no data to blit out
-	// so to avoid branches, split the read block in half
-//TODO: why do this fix work???
-	unsigned long is_new = 0; //cmp_eq(old_size, 0);
-	unsigned long cmd = if_then_else(is_new, MFC_GETL_CMD, MFC_PUTLF_CMD);
-	eal_old = if_then_else(is_new, eal_new+half_new_size, eal_old);
-	new_size = if_then_else(is_new, half_new_size, new_size);
-	old_size = if_then_else(is_new, half_new_size, old_size);
-
-#ifdef DEBUG_2
-	printf("old_size %d, is_new %d store_new %d\n",
-		active->current_length, is_new&1, store_new_size);
-	printf("DMA[%02X]: ls=%lx eah=%lx list=%lx, size=%d, tag=%d\n",
-		cmd, &active->pixels[0],eah,eal_old,old_size,tag);
-	printf("DMA[%02X]: ls=%lx eah=%lx list=%lx, size=%d, tag=%d\n",
-		MFC_GETLF_CMD, &active->pixels[0],eah,eal_new,new_size,tag);
-#endif
-
-	spu_mfcdma64(&active->pixels[0],eah,eal_old,old_size,tag, cmd);
-	spu_mfcdma64(&active->pixels[0],eah,eal_new,new_size,tag, MFC_GETLF_CMD);
+	spu_mfcdma64(&active->pixels[0],eah,eal_new,new_size,tag, MFC_GETLB_CMD);
 
 	// update the buffer pointers
 	active->current_length = store_new_size;
@@ -172,6 +153,21 @@ void blockActivater(Block* block, ActiveBlock* active, int tag)
 
 //////////////////////////////////////////////////////////////////////////////
 
+void blockPassivater(Block* block, ActiveBlock* active, int tag)
+{
+	unsigned int bx=block->bx, by=block->by;
+	unsigned long long ea = screen.address + screen.bytes_per_line*by*32+bx*128;
+
+	unsigned long eah = ea >> 32;
+	unsigned long eal = ((unsigned long) (ea&0xffffffff));
+
+	unsigned long old_size = active->current_length;
+	unsigned long eal_old = (unsigned long) ((void*)active->current_dma);
+	spu_mfcdma64(&active->pixels[0],eah,eal_old,old_size,tag, MFC_PUTL_CMD);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
 #ifdef __IGNORE_ALL_JUNK
 
 int qs(int a) { return a>>5; }
diff --git a/queue.c b/queue.c
index 83b7a42..306c8d3 100644
--- a/queue.c
+++ b/queue.c
@@ -98,7 +98,7 @@ void flush_queue()
 	mfc_read_tag_status_all();
 }
 
-void process_queue(TriangleGenerator* generator, BlockActivater* activate)
+void process_queue(TriangleGenerator* generator, BlockActivater* activate, BlockActivater* passivate)
 {	
 	mfc_write_tag_mask((1<<NUMBER_OF_ACTIVE_BLOCKS)-1);
 	unsigned int completed = mfc_read_tag_status_immediate();
@@ -118,21 +118,27 @@ void process_queue(TriangleGenerator* generator, BlockActivater* activate)
 					block->process = next;
 //					printf("stalled %d: %d\n", i, id);
 				} else {
-//					printf("finished %d: %d\n", i, id);
-					busy--;
-					block->process = next;
-					free_blocks |= 1<<id;
-					active_blocks = spu_insert( (unsigned short)-1,
-								    active_blocks, i);
+					printf("finished %d: %d\n", i, id);
 					next_bit = chained_block[id];
-					clear_hash(id);
 					if (next_bit>=0) {
-//						printf("from %d, next_bit %d\n", id, next_bit);
+						printf("from %d, next_bit %d\n", id, next_bit);
+						free_blocks |= 1<<id;
 						chained_block[id] = -1;
-						ready_blocks |= 1<<next_bit;
-						goto queue_chained;
+						next_mask = 1<<next_bit;
+						ready_blocks &= ~next_mask;
+						last_block_started = next_bit;
+						active_blocks = spu_insert( (unsigned short)next_bit,
+								    	active_blocks, i);
+					} else {
+						printf("passivating %d, %d\n", id, next_bit);
+						busy--;
+						block->process = next;
+						free_blocks |= 1<<id;
+						active_blocks = spu_insert( (unsigned short)-1,
+								    	active_blocks, i);
+						clear_hash(id);
+						passivate(&blocks[next_bit], &active[i], i);
 					}
-					goto queue_next;
 				}
 			} else {
 queue_next:
diff --git a/queue.h b/queue.h
index f9cf681..ddd2e25 100644
--- a/queue.h
+++ b/queue.h
@@ -26,7 +26,7 @@
 
 #define NUMBER_OF_TRIS	10	
 #define NUMBER_OF_QUEUED_BLOCKS 32
-#define NUMBER_OF_ACTIVE_BLOCKS 1
+#define NUMBER_OF_ACTIVE_BLOCKS 3
 
 typedef struct __BLOCK Block;
 typedef struct __TRIANGLE Triangle;
@@ -96,7 +96,7 @@ struct __ACTIVE {
 
 extern void flush_queue();		// push all active blocks to the screen
 extern void init_queue(ActiveBlockInit* init, ActiveBlockFlush* flush);
-extern void process_queue(TriangleGenerator* generator, BlockActivater* activate);
+extern void process_queue(TriangleGenerator* generator, BlockActivater* activate, BlockActivater* passivate);
 
 extern void _init_buffers();
 
diff --git a/spufifo.c b/spufifo.c
index bb4ebdc..70e0ce2 100644
--- a/spufifo.c
+++ b/spufifo.c
@@ -103,6 +103,7 @@ int fifoTriangleGenerator(Triangle* tri)
 }
 
 extern void blockActivater(Block* block, ActiveBlock* active, int tag);
+extern void blockPassivater(Block* block, ActiveBlock* active, int tag);
 extern void activeBlockInit(ActiveBlock* active);
 extern void activeBlockFlush(ActiveBlock* active, int tag);
 
@@ -124,6 +125,6 @@ int main(unsigned long long spe_id, unsigned long long program_data_ea, unsigned
 
 	int running = 1;
 	while (running) {
-		process_queue(&fifoTriangleGenerator, &blockActivater);
+		process_queue(&fifoTriangleGenerator, &blockActivater, &blockPassivater);
 	}
 }
